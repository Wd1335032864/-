<<<<<<< HEAD
# lab1_challenge2_errorline
=======
# Lab1_3_irq

- 继承lab1_2以及之前的答案

```
git merge lab1_2_exception -m "continue to work on lab1_3"
```

- 首先由文档知道时钟中断也是在机器模式下触发，所以和lab1_2一样最终会进入到handle_mtrap函数继进行理，通过对mcause的值判断后确认是CAUSE_MTIMER后调用handle_timer()函数进行进一步处理。

- 而m_start中新增的timerinit()函数则是定义了下次timer触发的时间，具体定义：

  ```
  void timerinit(uintptr_t hartid) {
    // fire timer irq after TIMER_INTERVAL from now.
    *(uint64*)CLINT_MTIMECMP(hartid) = *(uint64*)CLINT_MTIME + TIMER_INTERVAL;
  
    // enable machine-mode timer irq in MIE (Machine Interrupt Enable) csr.
    write_csr(mie, read_csr(mie) | MIE_MTIE);
  }
  ```

- 第二行是允许我们在M模式下处理timer中断

- 再回到handle_timer()函数：

  ```
  static void handle_timer() {
    int cpuid = 0;
    // setup the timer fired at next time (TIMER_INTERVAL from now)
    *(uint64*)CLINT_MTIMECMP(cpuid) = *(uint64*)CLINT_MTIMECMP(cpuid) + TIMER_INTERVAL;
  
    // setup a soft interrupt in sip (S-mode Interrupt Pending) to be handled in S-mode
    write_csr(sip, SIP_SSIP);
  }
  ```

- 可以发现它会在中断发生后，再次设置timer的触发时间，即当前时间+TIMER_INTERVAL。需要注意的是这里第二行对SIP寄存器的SIP_SSIP位进行设置，会导致PKE操作系统内核在S模式收到一个来自M态的时钟中断请求，所以直接转入S态的trap处理函数入口smode_trap_vector，然后调用smode_trap_handler()函数 

  ```
  if (cause == CAUSE_USER_ECALL) {
      handle_syscall(current->trapframe);
    } else if (cause == CAUSE_MTIMER_S_TRAP) {  //soft trap generated by timer interrupt in M mode
      handle_mtimer_trap();
    } else {
      sprint("smode_trap_handler(): unexpected scause %p\n", read_csr(scause));
      sprint("            sepc=%p stval=%p\n", read_csr(sepc), read_csr(stval));
      panic( "unexpected exception happened.\n" );
    }
  
  ```

- 与lab1_1一样，读取scause寄存器内容判断中断类型，如果内容等于CAUSE_MTIMER_S_TRAP的话，说明是M态传递上来的时钟中断动作，就调用handle_mtimer_trap()函数进行处理

- 再观察handle_mtimer_trap():

  ```
  static uint64 g_ticks = 0;
  void handle_mtimer_trap() {
    sprint("Ticks %d\n", g_ticks);
    // TODO (lab1_3): increase g_ticks to record this "tick", and then clear the "SIP"
    // field in sip register.
    // hint: use write_csr to disable the SIP_SSIP bit in sip.
    panic( "lab1_3: increase g_ticks by one, and clear SIP field in sip register.\n" );
  
  }
  ```

- 将通过之前不正确的输出可以知道g_ticks是输出中断次数，所以每次调用该函数需要使其加一。因为该程序在一次时钟中断后还要继续运行，所以我们需要将SIP寄存器中的SIP_SSIP位置零，让我们的模拟RISC-V机器不再处于中断状态，以便S态能继续处理下次时钟中断时M态传来的时钟中断请求

- 最终修改为：

  ```
  void handle_mtimer_trap() {
    sprint("Ticks %d\n", g_ticks);
    // TODO (lab1_3): increase g_ticks to record this "tick", and then clear the "SIP"
    // field in sip register.
    // hint: use write_csr to disable the SIP_SSIP bit in sip.
  	g_ticks++;
  	write_csr(sip,0);
  }
  ```

  

# 记录

为何不在M态完整处理时钟中断：
根据文档：对于一个操作系统来说，timer事件对它的意义在于，它是标记时间片的重要（甚至是唯一）手段，而将CPU事件分成若干时间片的作用很大程度上是为了做进程的调度，同时，操作系统的功能大多数是在S态完成的。如果在M态处理时钟中断，虽然说特权级上允许这样的操作，但是处于M态的程序可能并不是非常清楚S态的操作系统的状态。如果贸然采取动作，可能会破坏操作系统本身的设计。
>>>>>>> lab1_3_irq
